/*
See LICENSE folder for this sampleâ€™s licensing information.

Abstract:
Metal shaders used to create G-buffer
*/
#include <metal_stdlib>

using namespace metal;

// Include header shared between this Metal shader code and C code executing Metal API commands
#include "AAPLShaderTypes.h"

// Include header shared between all Metal shader code files
#include "AAPLShaderCommon.h"

// Per-vertex inputs fed by vertex buffer laid out with MTLVertexDescriptor in Metal API
struct DescriptorDefinedVertex
{
    float3 position  [[attribute(VertexAttributePosition)]];
    float2 tex_coord [[attribute(VertexAttributeTexcoord)]];
    half3 normal     [[attribute(VertexAttributeNormal)]];
    half3 tangent    [[attribute(VertexAttributeTangent)]];
    half3 bitangent  [[attribute(VertexAttributeBitangent)]];
};

// Vertex shader outputs and per-fragment inputs.  Includes clip-space position and vertex outputs
// interpolated by rasterizer and fed to each fragment generated by clip-space primitives.
struct ColorInOut
{
    float4 position [[position]];
    float2 tex_coord;
    float3 eye_position;
    float3 shadow_position;
    half3  tangent;
    half3  bitangent;
    half3  normal;
    float4 model_position;
};

vertex ColorInOut gbuffer_vertex(DescriptorDefinedVertex in    [[ stage_in ]],
                                 constant FrameData &frameData [[ buffer(BufferIndexFrameData) ]])
{
    ColorInOut out;

    float4 model_position = float4(in.position, 1.0);
    // Make position a float4 to perform 4x4 matrix math on it
    float4 eye_position = frameData.temple_modelview_matrix * model_position;
    float4 shadow_position = frameData.shadow_view_matrix * frameData.temple_model_matrix * model_position;
    out.shadow_position = shadow_position.xyz;
    out.position = frameData.projection_matrix * eye_position;
    out.tex_coord = in.tex_coord;

#if USE_EYE_DEPTH
    out.eye_position = eye_position.xyz;
#endif

    // Rotate tangents, bitangents, and normals by the normal matrix
    half3x3 normalMatrix = half3x3(frameData.temple_normal_matrix);

    out.model_position = model_position;

    // Calculate tangent, bitangent and normal in eye's space
    out.tangent = normalize(normalMatrix * in.tangent);
    out.bitangent = -normalize(normalMatrix * in.bitangent);
    out.normal = normalize(normalMatrix * in.normal);

    return out;
}

constant half4 CASCADE_RANGE_COLORS[CASCADED_SHADOW_COUNT] = {
    vector_half4(0.2, 0, 0, 0),
    vector_half4(0, 0.2, 0, 0),
    vector_half4(0, 0, 0.2, 0)
};

fragment GBufferData gbuffer_fragment(ColorInOut               in           [[ stage_in ]],
                                      constant FrameData & frameData    [[ buffer(BufferIndexFrameData) ]],
                                      texture2d<half>          baseColorMap [[ texture(TextureIndexBaseColor) ]],
                                      texture2d<half>          normalMap    [[ texture(TextureIndexNormal) ]],
                                      texture2d<half>          specularMap  [[ texture(TextureIndexSpecular) ]],
                                      depth2d_array<float>           shadowMap    [[ texture(TextureIndexShadow) ]],
                                      device atomic_int * lightFrustumBoundingBox [[ buffer(BufferIndexBoundingBox) ]])
{
    constexpr sampler linearSampler(mip_filter::linear,
                                    mag_filter::linear,
                                    min_filter::linear);

    half4 base_color_sample = baseColorMap.sample(linearSampler, in.tex_coord.xy);
    half4 normal_sample = normalMap.sample(linearSampler, in.tex_coord.xy);
    half specular_contrib = specularMap.sample(linearSampler, in.tex_coord.xy).r;

    // Fill in on-chip geometry buffer data
    GBufferData gBuffer;

    // Calculate normal in eye space
    half3 tangent_normal = normalize((normal_sample.xyz * 2.0) - 1.0);

    half3 eye_normal = (tangent_normal.x * in.tangent +
                        tangent_normal.y * in.bitangent +
                        tangent_normal.z * in.normal);

    eye_normal = normalize(eye_normal);

    // fragment shadowing

    float2 shadow_uv = vector_float2(0, 0);
    float shadow_depth = 0;
    int shadow_index = -1;
    int cascade_index = -1;

    half4 cascadeRangeColor = vector_half4(0, 0, 0, 0);

    // Determine in which shadow layer the fragment is
    for (int i = 0; i < CASCADED_SHADOW_COUNT; i++) {
        if (in.eye_position.z >= frameData.cascadeEnds[i] && in.eye_position.z < frameData.cascadeEnds[i + 1]) {
            cascadeRangeColor = CASCADE_RANGE_COLORS[i];
            cascade_index = i;
        }

        float3 shadow_coord = (frameData.shadow_mvp_xform_matrices[i] * in.model_position).xyz;

        if (shadow_coord.x < 1.0 && shadow_coord.x > 0.0 && shadow_coord.y < 1.0 && shadow_coord.y > 0.0 &&
            in.eye_position.z < frameData.cascadeEnds[i + 1] && in.eye_position.z >= frameData.cascadeEnds[i]
        ) {
            shadow_uv = shadow_coord.xy;
            shadow_depth = half(shadow_coord.z);
            shadow_index = i;
            break;
        }
    }

//    if (cascade_index > -1) {
//
//        atomic_fetch_min_explicit(&lightFrustumBoundingBox[6 * cascade_index + BoundingBoxMinX],
//                                  as_type<int>((int)(in.shadow_position.x * LARGE_INTEGER)),
//                                  memory_order_relaxed);
//        atomic_fetch_min_explicit(&lightFrustumBoundingBox[6 * cascade_index + BoundingBoxMinY],
//                                  as_type<int>((int)(in.shadow_position.y * LARGE_INTEGER)),
//                                  memory_order_relaxed);
//        atomic_fetch_min_explicit(&lightFrustumBoundingBox[6 * cascade_index + BoundingBoxMinZ],
//                                  as_type<int>((int)(in.shadow_position.z * LARGE_INTEGER)),
//                                  memory_order_relaxed);
//
//        atomic_fetch_max_explicit(&lightFrustumBoundingBox[6 * cascade_index + BoundingBoxMaxX],
//                                  as_type<int>((int)(in.shadow_position.x * LARGE_INTEGER)),
//                                  memory_order_relaxed);
//        atomic_fetch_max_explicit(&lightFrustumBoundingBox[6 * cascade_index + BoundingBoxMaxY],
//                                  as_type<int>((int)(in.shadow_position.y * LARGE_INTEGER)),
//                                  memory_order_relaxed);
//        atomic_fetch_max_explicit(&lightFrustumBoundingBox[6 * cascade_index + BoundingBoxMaxZ],
//                                  as_type<int>((int)(in.shadow_position.z * LARGE_INTEGER)),
//                                  memory_order_relaxed);
//
//    }

    constexpr sampler shadowSampler(coord::normalized,
                                    filter::linear,
                                    mip_filter::none,
                                    address::clamp_to_edge,
                                    compare_func::less);

    // Compare the depth value in the shadow map to the depth value of the fragment in the sun's.
    // frame of reference.  If the sample is occluded, it will be zero.
    half shadow_sample = 1.0;

    if (shadow_index > -1) {
        shadow_sample = shadowMap.sample_compare(shadowSampler, shadow_uv, shadow_index, shadow_depth);
    }

    // Store shadow with albedo in unused fourth channel
    if (frameData.visualization_mode == VISUALIZE_NORMAL) {
        gBuffer.albedo_specular = half4(base_color_sample.xyz, specular_contrib);
    } else if (frameData.visualization_mode == VISUALIZE_CASCADE) {
        gBuffer.albedo_specular = half4(base_color_sample.xyz, specular_contrib) + cascadeRangeColor;
    } else if (frameData.visualization_mode == VISUALIZE_ALIASING_ERROR) {
        float aliasing_error = 1.0 / (in.eye_position.z * tan(frameData.fov / 2.0f))*
            (frameData.cascadeEnds[shadow_index + 1] - frameData.cascadeEnds[shadow_index]) *
            frameData.screenWidth / (float)SHADOW_MAP_RES / 2.0f * 0.5f;

        gBuffer.albedo_specular = half4(aliasing_error, 1.0f - aliasing_error, 0.0f, 1.0f);
    }

    // Store the specular contribution with the normal in unused fourth channel.
    gBuffer.normal_shadow = half4(eye_normal.xyz, shadow_sample);

#if USE_EYE_DEPTH
    gBuffer.depth = in.eye_position.z;
#else
    gBuffer.depth = in.position.z;
#endif

    return gBuffer;
}
